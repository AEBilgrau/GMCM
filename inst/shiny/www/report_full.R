#' ---
#' title: "Unsupervised clustering with general GMCMs"
#' output: html_document
#' date: '`r Sys.time()`'
#' author: "Generated by the GMCM shiny app"
#' params:
#'   file: !r file.path(getwd(), "../../../data/freshVsFrozen.csv")
#'   header: TRUE
#'   sep: ";"
#'   quote: '"'
#'   model_cols: !r c("PreVsPost.Fresh.pval", "PreVsPost.Frozen.pval")
#'   theta: !r GMCM::rtheta(m = 2, d = 2)
#'   fit_method: "NM"
#'   max_ite: 50
#'   full_class_type: "thres_prob"
#'   full_thres_prob: 0.9
#' ---


# ---- knit-int, echo=FALSE, include=FALSE
set.seed(7869670)

#'
#' ## Initalisation
#' The **GMCM**^[1][1]^ package is loaded.
# ---- load-packages, include=TRUE

#install.packages("GMCM")  # Uncomment to install the GMCM package
library("GMCM")

#'
#' If **GMCM** is *not* installed, please uncomment the above line and rerun the script.
#'
#' ## Load data
#' The data is loaded and the first rows are printed
# ---- load-data, include=TRUE, echo=TRUE
ds <- read.table(file   = params$file,
                 header = params$header,
                 sep    = params$sep,
                 quote  = params$quote)
head(ds, n = 4)

#'
#' Next, the data is subset to the columns of interest.
# ---- select-data, include=TRUE, echo=TRUE
x <- ds[, params$model_cols]
head(x, n = 2)

#'
#' ## Initial parameters
#' The initial parameters, as chosen in the application, are given by
# ---- show-initial-params, include=TRUE, echo=TRUE
theta <- as.theta(params$theta)
print(theta)

#'
#' ## Model fitting
#' With the data loaded and defined initial parameters, the model is now fitted.
# ---- fit_model, error=TRUE
theta <- fit.full.GMCM(u = x,  # Ranking function is applied automatically
                       theta = theta,
                       method = params$fit_method,
                       max.ite = params$max_ite,
                       verbose = FALSE)
print(theta)

#'
#' The fitting method is set `r params$fit_method` with a maximum number of iterations of `r params$max_ite`.
#'
#' ## Unsupervised clustering
#' The estimated parameters are used to calculated posterior component probabilities on which the classification is based:
# ---- compute_probs
kappa <- get.prob(x, theta) # Compute component probabilities
colnames(kappa) <- paste0("comp", seq_len(ncol(kappa))) # Add names

comps <- apply(kappa, 1, which.max) # Find index of maximum entry for each row

if (params$full_class_type == "thres_prob") {
  ok_max <- apply(kappa, 1, max) > params$full_thres_prob
  comps[!ok_max] <- NA
}

cols <- topo.colors(ncol(kappa))[comps]
cols[is.na(comps)] <- "gray"
res <- data.frame(kappa, comp = comps, col = cols,
                  stringsAsFactors = FALSE)
head(res)
summary(res)

#'
#' ## Results
#' The classes are counted by
# ---- classes_table
table(res$comp)

#' The results are also displayed by plotting
# ---- plot_results
plot(x, col = res$col, asp = 1) # Plot of raw values
plot(Uhat(x), col = res$col, asp = 1) # Plot of copula values
z <- GMCM:::qgmm.marginal(Uhat(x), theta = theta) # Estimate latent process
plot(z, col = res$col, asp = 1) # Plot of estimated latent process


#' The fitted `theta` object can also be plotted directly:
# ---- plot_theta
plot(theta)

#'
#' ### Session information
#' This report was generated using **rmarkdown**^[2][2]^ and **knitr**^[3][3]^ under the session
#' given below. The report utilizes [parameterized reports][2] and [`knitr::spin`][3].
#'
# ---- session-info
sessionInfo()

#'
#' ### References
#' Please cite the **GMCM** paper^[1][1]^ if you use the package or shiny app.
# ---- citation, echo=FALSE, results='asis'
cites <- lapply(c("GMCM", "knitr", "rmarkdown"), citation)
fmt_cites <- unlist(lapply(cites, format, style = "text"))
cat(paste0("  ", seq_along(fmt_cites), ". ", fmt_cites, "\n"))



#' [1]: http://doi.org/10.18637/jss.v070.i02
#' [2]: https://bookdown.org/yihui/rmarkdown/parameterized-reports.html
#' [3]: https://yihui.name/knitr/demo/stitch/
